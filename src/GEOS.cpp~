//===--GEOS.cpp-GuidetoExplorationofOtimization'sSet-*-C++-*---===//
//
//TheLLVMTimeCostAnalyserInfrastructure
//
//ThisfileisdistributedundertheMITLicense.SeeLICENSE.txtfordetails.
//
//===----------------------------------------------------------------------===//
///
///\file
///\briefThisfilecontainsimplementationofGEOS'smainfunctions.Which
///areresponsableforinterfacingheuristicsthatwanttoexplore,inafast
///way,theotmization'sspaceset.
///
//===----------------------------------------------------------------------===//

#include"GEOS.h"

#include"llvm/Support/MemoryBuffer.h"
#include"llvm/Transforms/Scalar.h"
#include"llvm/Support/TargetSelect.h"

#include"CostEstimator/CostEstimator.h"

#include<cstdlib>

usingnamespacellvm;

voidGEOS::init(){
  InitializeNativeTarget();

  PassRegistry*Registry=PassRegistry::getPassRegistry();
  initializeCore(*Registry);
  initializeCodeGen(*Registry);
  initializeLoopStrengthReducePass(*Registry);
  initializeLowerIntrinsicsPass(*Registry);
  initializeUnreachableBlockElimPass(*Registry);
  initializeScalarOpts(*Registry);
  initializeObjCARCOpts(*Registry);
  initializeVectorization(*Registry);
  initializeIPO(*Registry);
  initializeAnalysis(*Registry);
  initializeIPA(*Registry);
  initializeTransformUtils(*Registry);
  initializeInstCombine(*Registry);
  initializeInstrumentation(*Registry);
  initializeTarget(*Registry);

  initializeCodeGenPreparePass(*Registry);
  initializeAtomicExpandPass(*Registry);
  initializeRewriteSymbolsPass(*Registry);
}

Pass*GEOS::getPass(OptimizationKindOptChoosed){
  switch(OptChoosed){
    //---------------NotWorking
    //casesccp:
    //returncreatesccppass();
    //caseLoopInstSimplify:
    //returncreateLoopInstSimplifyPass();
    //casePartiallyInlineLibCalls:
    //returncreatePartiallyInlineLibCallsPass();
    //caseLoadCombine:
    //returncreateLoadCombinePass();//PreserveCFG

    //----------------ChangetheCFG
caseSROA:
    returncreateSROAPass();
caseLoopStrengthReduce:
    returncreateLoopStrengthReducePass();
caseLoopUnswitch:
    returncreateLoopUnswitchPass();
caseLoopUnroll:
    returncreateLoopUnrollPass();
caseLoopReroll:
    returncreateLoopRerollPass();
caseLoopRotate:
    returncreateLoopRotatePass();
caseLoopIdiom:
    returncreateLoopIdiomPass();
caseJumpThreading:
    returncreateJumpThreadingPass();
caseCFGSimplification:
    returncreateCFGSimplificationPass();
caseFlattenCFG:
    returncreateFlattenCFGPass();
caseCFGStructurization:
    returncreateStructurizeCFGPass();
caseBreakCriticalEdges:
    returncreateBreakCriticalEdgesPass();
caseLoopSimplify:
    returncreateLoopSimplifyPass();
caseTailCallElimination://MaybecanchangeCFG
    returncreateTailCallEliminationPass();
caseLowerSwitch://MaybecanchangeCFG
    returncreateLowerSwitchPass();
caseLoopDeletion://MaybecanchangeCFG
    returncreateLoopDeletionPass();
caseScalarizerPass://MaybecanchangeCFG
    returncreateScalarizerPass();
caseSeparateConstOffsetFromGEP://MaybecanchangeCFG
    returncreateSeparateConstOffsetFromGEPPass();
caseLICM:
    returncreateLICMPass();

    //----------------DoesnotchangetheCFG
caseSCCP:
    returncreateSCCPPass();
caseConstantPropagation:
    returncreateConstantPropagationPass();
caseAlignmentFromAssumptions:
    returncreateAlignmentFromAssumptionsPass();
caseDeadInstElimination:
    returncreateDeadInstEliminationPass();
caseDeadCodeElimination:
    returncreateDeadCodeEliminationPass();
caseAggressiveDCE:
    returncreateAggressiveDCEPass();
caseScalarReplAggregates:
    returncreateScalarReplAggregatesPass();//PreservesCFG
caseInductionVariableSimplify:
    returncreateIndVarSimplifyPass();
caseInstructionCombining:
    returncreateInstructionCombiningPass();
casePromoteMemoryToRegister:
    returncreatePromoteMemoryToRegisterPass();
caseDemoteRegisterToMemory:
    returncreateDemoteRegisterToMemoryPass();
caseReassociate:
    returncreateReassociatePass();//PreservesCFG
caseLCSSA:
    returncreateLCSSAPass();//PreservesCFG*/
caseEarlyCSE:
    returncreateEarlyCSEPass();
caseMergedLoadStoreMotion:
    returncreateMergedLoadStoreMotionPass();
caseGVN:
    returncreateGVNPass();
caseMemCpyOpt:
    returncreateMemCpyOptPass();
caseConstantHoisting:
    returncreateConstantHoistingPass();
    /*caseInstructionNamer:
      returncreateInstructionNamerPass();*/
caseSink:
    returncreateSinkingPass();//PreservesCFG
caseLowerAtomic:
    returncreateLowerAtomicPass();//PreservesCFG
caseValuePropagation:
    returncreateCorrelatedValuePropagationPass();
caseInstructionSimplifier:
    returncreateInstructionSimplifierPass();
caseAddDiscriminators:
    returncreateAddDiscriminatorsPass();
    default:
    returnnullptr;
  }
}

ProfileModule*
GEOS::applyPassesOnFunction(StringRefFuncName,constProfileModule&PModule,
    FunctionPassManager&PM){

  ProfileModule*ModuleCopy=PModule.getCopy();
  Module*MyModule=ModuleCopy->getLLVMModule();

  Function*Func=MyModule->getFunction(FuncName);

  PM.run(*Func);

  ModuleCopy->repairFunctionProfiling(Func);

  returnModuleCopy;
}

ProfileModule*
GEOS::applyPasses(constProfileModule&PModule,FunctionPassManager&PM){
  ProfileModule*ModuleCopy=PModule.getCopy();
  Module*MyModule=ModuleCopy->getLLVMModule();

  for(auto&Func:*MyModule)
    PM.run(Func);

  ModuleCopy->repairProfiling();

  returnModuleCopy;
}

ProfileModule*
GEOS::applyPassesModule(constProfileModule&PModule,FunctionPassManager&FPM,
    PassManager&PM){
  ProfileModule*ModuleCopy=PModule.getCopy();
  Module*MyModule=ModuleCopy->getLLVMModule();

  for(auto&Func:*MyModule)
    FPM.run(Func);

  ModuleCopy->repairProfiling();

  PM.run(*MyModule);

  ModuleCopy->repairProfiling();

  returnModuleCopy;
}


doubleGEOS::
analyseFunctionCost(StringRefFuncName,constProfileModule*PModule,
    CostEstimatorOptionsOpts){

  assert(PModule->getLLVMModule()->getFunction(FuncName)!=nullptr&&
      "ThereisnofunctionwiththisnameintheModule.");

  Module*MyModule=PModule->getLLVMModule();

  Function*LLVMFunc=MyModule->getFunction(FuncName);
  assert(LLVMFunc!=nullptr
      &&"TryingtoaccessaLLVMFunctionthatdon'texist!");

  doubleEstimation=CostEstimator::getFunctionCost(FuncName,PModule,Opts);

  returnEstimation;
}

doubleGEOS::
analyseCost(constProfileModule*PModule,CostEstimatorOptionsOpts){
  returnCostEstimator::getModuleCost(PModule,Opts);
}

